# 機械語とアセンブラ
コンピュータを構成するコンポーネントと、作成するCコンパイラからどのようなコードを出力すればよいのかということについて、大まかなイメージをつかむことを目標とする。

## サマリ
* CPUはメモリを読み書きすることでプログラムの実行を進めていく。
* CPUが実行するプログラムと、そのプログラムが扱うデータは、どちらもメモリに入っていて、CPUはメモリから順に機械語命令を読み、その命名を実行する。
* CPUにはレジスタという小さな記憶領域があり、多くの機械語はレジスタ間での操作として定義されている。
* アセンブリは機械語を人間にとって読みやすくした言語で、Cコンパイラは普通はアセンブリを出力する。
* Cの関数はアセンブリでも関数になる。
* 関数呼び出しはスタックを使って実装されている。

## CPUとメモリ
* コンピュータを構成するコンポーネントは、CPUとメモリに分けることができる。
  * メモリはデータを保持するデバイス
  * CPUは、メモリを読み書きしながら何らかの処理を行うデバイス
* CPUが実行するプログラムと、そのプログラムが読み書きするデータは、どちらもメモリに入っている。
  * CPUは「現在実行中の命令のアドレス」をCPU内部に保存していて、そのアドレスから命令を読み出してそこに書かれていることを行い、次の命令を読み出して実行する、ということを行なっている。


## アセンブラとは
* 機械語はCPUが直接読んでいくものなので、CPUの都合だけが考慮されていて、人間にとっての扱いやすさは考慮されていない。
  * 機械語をバイナリエディタで書いていくのは不可能ではないがとても辛い。
* そこで発明されたのがアセンブラ。
  * アセンブリは機械語にほぼ1対1で対応するような言語だが、機械語よりも人間にとっては読みやすい。
* **仮想マシンやインタプリタではなくネイティブなバイナリを出力するコンパイラの場合、通常はアセンブラを出力することが目標になる。**
* **機械語を直接出力しているように見えるコンパイラも、よくある構成では、アセンブリを出力したあとにバックグラウンドでアセンブラを起動している。**
* **ここで作るCコンパイラもアセンブリを出力する。**

#### 例
* `objdump` コマンドを使って、適当な実行ファイルを逆アセンブルして、その中に入っている機械語をアセンブリとして表示してみる。
* 以下は `ls` コマンドを逆アセンブルしてみた結果。

```shell
% objdump -d /bin/ls
/bin/ls (architecture x86_64):
(__TEXT,__text) section
10000091c:	55	pushq	%rbp
10000091d:	48 89 e5	movq	%rsp, %rbp
100000920:	48 83 c7 68	addq	$0x68, %rdi
100000924:	48 83 c6 68	addq	$0x68, %rsi
100000928:	5d	popq	%rbp
100000929:	e9 06 3c 00 00	jmp	0x100004534 ## symbol stub for: _strcoll
10000092e:	55	pushq	%rbp
...
```


## Cとそれに対応するアセンブラ
### 簡単な例
Cコードとそれに対応するアセンブリコードを比較してみる。簡単な例として次のプログラムを考える（`test1.c`）

```c
int main()
{
    return 42;
}
```

次のようにコンパイルして、`main` が実際に42を返すことが確認できる。

```shell
% cc -o test1 test1.c
% ./test1
% echo $?
42
```

Cでは、`main` 関数が返した値がプログラム全体の終了コードになる。プログラムの終了コードは画面に表示されることはないが、暗黙的に `$?` という変数にセットされる。

以下が、このCプログラムに対応するアセンブリプログラムになる（補足で後述）。

```
.globl _main
_main:
        mov x0, 42
        ret
```

このアセンブリプログラムを実際にアセンブルしてみる。上のアセンブリが `test2.s` に書かれているとして次のコマンドを実行する。

```shell
% cc -o test2 test2.s
% ./test2
% echo $?
42
```

大雑把にいうと、Cコンパイラは `test1.c` のようなCコードを読み込んで、`test2.s` のようなアセンブリを出力するプログラムである。

#### 補足
資料に載っているアセンブリコードをM1Macでアセンブルしようとすると次のエラーが出る（コンテナからアセンブルしようとしたときもいくつか同じエラーが出た）。

```
// 修正前のアセンブリコード
.intel_syntax noprefix
.globl main
main:
        mov rax, 42
        ret
```

```shell
# コマンドと実行結果
% cc -o test2 test2.s
test2.s:1:1: error: unknown directive
.intel_syntax noprefix
^
test2.s:4:13: error: invalid operand for instruction
        mov rax, 42
            ^
```

```
// 修正後のアセンブリコード
.globl _main
_main:
        mov x0, 42
        ret
```
* `_main`: macOSでは、エントリーポイントのシンボル名は `_main` を使う。
* `mov x0, 42`: 関数の戻り値は `x0` レジスタに格納する。
* `ret`: 関数からリターンする。


### 関数呼び出しを含む例
* 関数呼び出しは単なるジャンプとは異なり、呼び出した関数が終了したあとに、もともと実行していた場所に戻ってこなければいけない。
  * もともと実行していたアドレスのことをリターンアドレスという。
  * リターンアドレスはメモリ上のスタックに保存される。

* 関数呼び出しの例（`test3.c`, `test3.s`）
```c
int plus(int x, int y) {
    return x + y;
}

int main()
{
    return plus(3, 4);
}
```

```
.globl plus, main

plus:
        add x0, x0, x1  // x0 = x0 + x1
        mov x2, x0      // x2 = x0
        ret

main:
        mov x0, 3       // x0 = 3
        mov x1, 4       // x1 = 4
        b plus          // call plus  ※ NOT bl plus
        ret
```

* `.globl plus, main`: `plus` と `main` がファイルスコープではなくプログラム全体から見える関数であることをアセンブリに指示する。
* `main`
  * Cでは、`plus` を引数付きで呼び出している。
  * （x86の場合）アセンブリでは、第一引数はRDIレジスタ、第二引数はRSIレジスタに入れるという約束になっている。
* `call`（ARM64では `b` or `bl`）は具体的に次のことを行う。
  * `call` の次の命令（この場合 `ret`）のアドレスをスタックにプッシュする。
  * `call` の引数として与えられたアドレスにジャンプする。
