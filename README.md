# c_compiler

## 資料
[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook#)

* はじめに
* 機械語とアセンブラ
* 電卓レベルの言語の作成
* 分割コンパイルとリンク
* 関数とローカル変数
* コンピュータにおける整数の表現
* ポインタと文字列リテラル
* プログラムの実行イメージと初期化式
* スタティックリンクとダイナミックリンク
* Cの型の構文
* おわりに
* 付録1：x86-64命令セット チートシート
* 付録2：Gitによるバージョン管理
* 付録3：Dockerを使った開発環境の作成

## 環境構築
参考にしたサイトではmacOSの利用は想定されておらず、Dockerでコンテナを作成する必要がある。私はM1 Macを使っているので、付録3に書いてある方法でコンテナを作成した。

### 前提
Dockerを使ってmacOS上でLinuxアプリケーションを開発する場合、次のシステム構成を考えることができる。
* Dockerの中と外の環境を全く別のものとして考える。Linuxのアプリケーションを開発するときは、すべての作業をDockerの中で行う構成
  * Macとは別にLinuxのマシンを用意して開発を行うのと同じなので構成が単純だが、Linux上での開発環境をエディタも含めて用意しないといけないのでやや面倒。
* ソースコードの編集やGitの操作など、プラットフォームに依存しない通常の開発作業はDockerの外で行い、ビルドやテストのコマンドのみDockerの中で実行する構成
  * 環境のセットアップを凝る必要がないが、Dockerの中と外を使い分けるのがやや面倒。
  * サイトではこちらの構成を選択していたので、ここでもそれに従うことにする。
  * Linux環境の中で走らせたいコマンドだけを明示的にDockerの中で実行することになる。

### 手順
1. Dockerのインストール
   * すでにインストールしていたのでここでは省略。
2. `compilerbook` のコンテナイメージの取得
   * 次のコマンドを実行：`docker build -t compilerbook https://www.sigbus.info/compilerbook/Dockerfile`
3. 動作確認
   * 次のコマンドを実行：`docker run --rm compilerbook ls /`
     * `docker run` の引数としてイメージ名とコマンドを与える。上記は `ls /` コマンドを `compilerbook` のコンテナの中で実行している。
     * 以下のような結果が出力されればOK
        ```shell
        bin
        boot
        dev
        etc
        ...
        ```
   * コンテナはバックグラウンドで動作させることも可能だが、ここではインタラクティブな使い方しか必要ない。`--rm` オプションを与えることで、コマンドが終了したらコンテナも終了するようにする。

## コンテナを使ったビルド
* **コンテナの中で `make` を実行してソースファイルをコンパイルするためには、Dockerの外で編集しているソースファイルをコンテナから見えるようにする必要がある。**
* `docker run` では `-v <source>:<dest>` というオプションを与えることで、外側の環境のパス `<source>` をDockerの中で `dest` として見えるようにすることができる。
* また、コマンドを実行するときのカレントディレクトリを `-w` オプションで指定することができる。このオプションを使うと、ソースファイルのあるディレクトリをカレントディレクトリにした上で `make` を実行することができる。
* 例えば、ホームディレクトリの `9cc` というサブディレクトリにソースファイルが置いてあるものとする。そのディレクトリに対してコンテナ内から `make test` を実行するためには、次のコマンドを実行する。
    ```shell
    docker run --rm -v $HOME/9cc:/9cc -w /9cc compilerbook make test
    ```

## コンテナに新たなアプリケーションを追加
* `compilerbook` のコンテナには一通りの開発ツールがインストールされているが、追加のアプリケーションをインストールしたいこともある。
* **Dockerコンテナはテンポラリな存在。つまり、コンテナを作ってその中のシェルからアプリケーションをインストールしても、そういった変更は元のイメージには書き戻されない。**
* コンテナに変更を加えたあとにそれをイメージに書き戻したい場合は、明示的に `docker commit` コマンドを実行する必要がある。
* 例として、`curl` コマンドをインストールしたいときの実行例を書く。
    ```shell
    $ docker run -it compilerbook  # --rmオプションは使わない
    $ sudo apt update
    $ sudo apt install -y curl
    $ exit
    ```
* `--rm` オプションを実行していないので、`exit` した後でもコンテナはサスペンド状態として残っている。`docker container -ls -a` を実行すると、サスペンドしたコンテナを表示することができる。
* `docker commit <CONTAINER ID> compilerbook` を実行するとイメージに変更を加えることができる。
* サスペンドしたコンテナや古いイメージ、残っていてもディスクスペースを少し消費するだけだが、気になる場合は `docker system prune` を実行することで削除できる。
